<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>iproute2 cheat sheet</title>
    <link rel="stylesheet" type="text/css" href="hint.css" />
    <style type="text/css">
      .wrapper { width: 1000px; margin: 0 auto; }
      .preface { width: 100%; float: left; }
      .section { border: #dadada solid 1px; width: 100%; float: left; margin-bottom: 2em; }
      
      .subsection { padding-bottom: 2em; padding-left: 5px; padding-right: 5px; }
      .subsection:nth-child(odd) { background-color: #ededed }

      .code { font-family: monospace; } pre { margin-left: 50px; }

      .copyright { text-align: center; }

      .contributors { border: #dadada solid 1px; width: 100%; float: left; }

       hr { height: 1px; background-color: #aaaaaa; border: 0 none; }
    </style>
    <script type="text/javascript">
    //<![CDATA[

      function expand(id) { document.getElementById(id).display = "" }

      // Generate table of contents
      // Only two levels
      // I could make it recursive, but we don't want infinite
      // nesting in this document, right?
      function gen_toc()
      {
           var toc_ol = document.getElementById('toc');

           var sections = document.getElementsByClassName('section');
           for(i=0; i<sections.length; i+=1)
           {
              var section_toc = document.createElement("li");

              // Generate section link
              // Name is taken from the first h3 occurence, if there's more
              // than one h3, it's a mistake
              var section_header = sections[i].getElementsByTagName('h3');
              var section_name = section_header[0].innerHTML;
              var section_link = document.createElement('a');
              section_link.innerHTML = section_name;
              section_link.href = "#" + section_name;
              section_toc.appendChild(section_link);

              // Create corresponding anchor and insert before the header
              var section_anchor = document.createElement('a');
              section_anchor.name = section_name;
              sections[i].insertBefore(section_anchor, section_header[0]);

              var subsections = sections[i].getElementsByClassName('subsection');
              var subsection_toc = document.createElement('ol');
              for(j=0;j<subsections.length;j+=1)
              {

                  // Generate subsection link
                  // Name is taken from first h4 occurence
                  var subsection_item = document.createElement('li');
                  var subsection_link = document.createElement('a');
                  var subsection_header = subsections[j].getElementsByTagName('h4');
                  var subsection_name = subsection_header[0].innerHTML;
                  subsection_link.innerHTML = subsection_name;
                  subsection_link.href = "#" + subsection_name;
                  subsection_item.appendChild(subsection_link);

                  // Generate and insert subsection link
                  var subsection_anchor = document.createElement('a');
                  subsection_anchor.name= subsection_name;
                  subsections[j].insertBefore(subsection_anchor, subsection_header[0]);
                  
                  subsection_toc.appendChild(subsection_item);
                  section_toc.appendChild(subsection_toc);
              }

              toc_ol.appendChild(section_toc);
           }

      }
    //]]>
    </script>
  </head>
  <body onload="gen_toc()">
    <div class="wrapper">
      <div class="preface">
        <p>iproute2 is the Linux networking toolkit that replaced net-tools (ifconfig, route, arp tc.)</p>
        <p>Old style network utilities like ifconfig and route are still there just for backwards compatibility
           and do not provide access to new features like policy-based routing or network namespaces.</p>
        <p>Note that iproute2 is a <strong>standard Linux tool</strong> since early 2000's. It's included in
           every distro by default, or at least available from the repos (OpenWRT is one of the cases).</p>
        <p>It was originally written by Alex Kuznetsov and now maintained by Stephen Hemminger.</p>
        <p>Also, note that all commands that change any settings (that is, not just display them) require
           root privileges.</p>
        <p>This document is provided "as is", without any warranty. The authors are not liable for any
           damage related to using it.</p>

        <ol id="toc">

        </ol>
      </div>
      <div class="section">
        <h3>Address management</h3>
        <hr />
        <p>In this section ${address} refers to host address in dotted decimal format, and
           ${mask} refers to subnet mask either in prefix length or dotted decimal format.
           That is, both 192.0.2.10/24 and 192.0.2.10/255.255.255.0 are equally acceptable.</p>
         <p> If you are not sure if something is a correct host address, use "ipcalc" or similar
             program to check.</p>
        <div class="subsection">
          <h4>Show all addresses</h4>
          <pre>ip address show</pre>
          <span>All "show" commands can be used with "-4" or "-6" options to show only IPv4 or IPv6 addresses.</span>
        </div>
        <div class="subsection">
          <h4>Show addresses for a single interface</h4>
          <pre>ip address show ${interface name} </pre>
          <span>Examples:</span> 
          <pre>ip address show eth0</pre>
        </div>
        <div class="subsection">
          <h4>Add address to an interface</h4>
          <pre>ip address add ${address}/${mask} dev ${interface name}</pre>
          <span>Examples:</span>
          <pre>ip address add 192.0.2.10/27 dev eth0</pre>
          <pre>ip address add 2001:db8:1::/48 dev tun10</pre>
          <p>You can add as many addresses as you want. The first address will be primary
             and will be used as source address by default.</p>
        </div>
        <div class="subsection">
          <h4>Add address with human-readable description</h4>
          <pre>ip address add ${address}/${mask} dev ${interface name} label ${interface name}:${description} </pre>
          <span>Examples:</span>
          <pre>ip address add 192.0.2.1/24 dev eth0 label eth0:my_wan_address</pre>
          <span>Interface name with a colon before label is required, some backwards compaibility issue.</span>
        </div>
        <div class="subsection">
          <h4>Delete an address</h4>
          <pre>ip address delete ${address}/${prefix} dev ${interface name}</pre>
          <span>Examples:</span>
          <pre>ip address delete 192.0.2.1/24 dev eth0</pre>
          <span>Interface name argument is required. Linux does allow to use the same address on multiple
                interfaces and it has valid use cases.</span>
        </div>
        <div class="subsection">
          <h4>Remove all addresses from an interface</h4>
          <pre>ip address flush dev ${interface name}</pre>
          <span>Examples:</span>
          <pre>ip address flush dev eth1</pre>
        </div> 
        <div class="subsection">
          <h4>Notes</h4> <br/>
          <span>Note that there is no way to rearrange addresses and replace the primary address.
                Make sure you set the primary address first.</span>
        </div>
      </div>

      <div class="section">
        <h3>Route management</h3>
        <hr />
        <p>In this section ${address} refers to subnet address in dotted decimal format, and
           ${mask} refers to subnet mask either in prefix length or dotted decimal format.
           That is, both 192.0.2.0/24 and 192.0.2.0/255.255.255.0 are equally acceptable.</p>
        <p><strong>Note:</strong> as per the section below, if you set up a static route,
           and it becomes useless because the interface goes down, it will be removed and
           <strong>never get back on its own</strong>. You may not have noticed this behaviour
           because in many cases additional software (e.g. NetworkManager or rp-pppoe)
           takes care of restoring routes associated with interfaces.</p>
        <p>If you are going to use your Linux machine as a router, consider installing
           a routing protocol stack suite like <a href="http://quagga.net">Quagga</a>
           or <a href="http://bird.network.cz">BIRD</a>. They serve as routing control plane,
           keeping configured routes and restoring them after link failures properly in general case, 
           and also providing dynamic routing protocol (e.g. OSPF and BGP) functionality.</p>
        <div class="subsection">
          <h4>Connected routes</h4>
          <p>Some routes appear in the system without explicit configuration (against your will). </p>
          <p>Once you assign an address to an interface, a route to the subnet it belongs
             is automatically created via the interface you assigned it too. This is exactly
             the reason "ip address add" command wants subnet mask, otherwise the system would
             be unable to find out its subnet address and create connected routes properly.</p>
          <p>When an interface goes down, connected routes associated with it are removed.
             This is used for inaccessible gateway detection so routes through gateways that
             went inaccessible are also removed. Same mechanism prevents you from creating 
             routes through inaccessible gateays.</p>
        </div>
        <div class="subsection">
          <h4>View all routes</h4>
          <pre>ip route</pre>
          <pre>ip route show</pre>
          <span>Show commands accept -4 and -6 options to view only IPv4 or IPv6 routes. 
                 If no options given, IPv4 routes are displayed. To view IPv6 routes, use:</span>
          <pre>ip -6 route</pre>
        </div>
        <div class="subsection">
          <h4>View routes to a network and all its subnets</h4>
          <pre>ip route show to root ${address}/${mask}</pre>
          <span>For example, if you use 192.168.0.0/24 subnet in a part of your network
                and it's broken into 192.168.0.0/25 and 192.168.0.128/25, you can see
                all those routes with:</span>
          <pre>ip route show to root 192.168.0.0/24</pre>
          <span>Note: the word "to" in this and other show commands is optional.</span>
        </div>
        <div class="subsection">
          <h4>View routes to a network and all supernets</h4>
          <pre>ip route show to match ${address}/${mask}</pre>
          <span>If you want to view routes to 192.168.0.0/24 and all larger subnets,
                use:</span>
          <pre>ip route show to match 192.168.0.0/24</pre>
          <span>As routers prefer more specific routes to less specific,
                this is often useful for debug in situations when traffic to a specific
                subnet is sent the wrong way because a route to itis missing
                but routes to larger subnets exist.</span>
        </div>
        <div class="subsection">
          <h4>View routes to exact subnet</h4>
          <pre>ip route show to exact ${address}/${mask}</pre>
          <span>If you want to see the routes to 192.168.0.0/25, but not to
                say 192.168.0.0/25 and 192.168.0.0/16, you can use:</span>
          <pre>ip route show to exact 192.168.0.0/24</pre>
        </div>
        <div class="subsection">
          <h4>View only the route actually used by the kernel</h4>
          <pre>ip route get ${address}/${mask}</pre>
          <span>Example:</span>
          <pre>ip route get 192.168.0.0/24</pre>
          <span>Note that in complex routing scenarios like multipath routing,
                the result may be "correct but not complete", as it always shows
                one route that will be used first. In most situations it's not
                a problem, but never forget to look at the corresponsing "show" command
                output too.</span>
        </div>
        <div class="subsection">
          <h4>View route cache</h4>
          <pre>ip route show cached</pre>
          <span>To speed up routing table lookups, Linux uses
                route caching. This commands displays the contents
                of the route cache. It can be combined with modifiers
                described above.</span>
        </div>
        <div class="subsection">
          <h4>Add route via gateway</h4>
          <pre>ip route add ${address}/${mask} via ${next hop}</pre>
          <span>Examples:</span>
          <pre>ip route add 192.0.2.128/25 via 192.0.2.1</pre>
          <pre>ip route add 2001:db8:1::/48 via 2001:db8:1::1</pre>
        </div>
        <div class="subsection">
          <h4>Add route via interface</h4>
          <pre>ip route add ${address}/${mask} dev ${interface name}</pre>
          <span>Example:</span>
          <pre>ip route add 192.0.2.0/25 dev ppp0</pre>
          <span>Interface routes are commonly used with point-to-point interfaces
                like PPP tunnels where next hop address is not required.</span>
        </div>
        <div class="subsection">
          <h4>Change or replace routes</h4>
          <p>You may use "change" command to change parameters of existing route.
             "Replace" command can be used to add new route or modify existing one if
             it doesn't exist. Examples:</p>
          <pre>ip route change 192.168.2.0/24 via 10.0.0.1</pre>
          <pre>ip route replace 192.0.2.1/27 dev tun0</pre> 
        </div>
        <div class="subsection">
          <h4>Delete a route</h4>
          <pre>ip route delete ${rest of the route statement}</pre>
          <span>Examples:</span>
          <pre>ip route delete 10.0.1.0/25 via 10.0.0.1</pre>
          <pre>ip route delete default dev ppp0</pre>
        </div>
        <div class="subsection">
          <h4>Default route</h4> <br/>
          <span>There is a shortcut to add default route.</span>
          <pre>ip route add default via ${address}/${mask}</pre>
          <pre>ip route add default dev ${interface name}</pre>
          <span>These are equivalent to:</span>
          <pre>ip route add 0.0.0.0/0 ${address}/${mask}</pre>
          <pre>ip route add 0.0.0.0/0 dev ${interface name}</pre>
          <span>With IPv6 routes it also works and is equivalent to ::/0</span>
          <pre>ip -6 route add default via 2001:db8::1</pre>
        </div>
        <div class="subsection">
          <h4>Blackhole routes</h4>
          <pre>ip route add blackhole ${address}/${mask}</pre>
          <span>Examples:</span>
          <pre>ip route add blackhole 192.0.2.1/32</pre>
          <p>Traffic to the networks with such routes is silently discarded.</p>
          <p>Blackhole routes have dual purpose. First one is straightforward, to discard traffic
             the hosts attempt to send to unwanted destinations, e.g. known malicious hosts.</p>
          <p>The second one is less obvious and uses the "longest match rule" as per RFC1812.
             In some cases you may need to make the router think it has a route to a larger subnet,
             e.g. when advertising the whole subnet via dynamic routing protocols. Large subnets
             are commonly broken into smaller parts, so if your subnet is 192.0.2.0/24, and you
             have assigned 192.0.2.1/25 and 192.0.2.129/25 to your interfaces, your system creates connected
             routes to the /25's, but not the whole /24, and routing daemons may not want to 
             advertise /24 because you have no route to that exact subnet. The solution is to setup
             a blackhole route to 192.0.2.0/24. Because routes to smaller subnets are preferred
             over larger subnets, it will not affect actual routing, but will convince routing
             daemons a route to the supernet exists.</p>
        </div>
        <div class="subsection">
          <h4>Other special routes</h4>
          <pre>ip route add unreachable ${address}/${mask}</pre>
          <pre>ip route add prohibit ${address}/${mask}</pre>
          <pre>ip route add throw ${address}/${mask}</pre>
          <span>These routes make the system discard packets and reply with an ICMP error message to the sender.</span>
          <dl>
            <dt>unreachable</dt>
            <dd>Sends ICMP "host unreachable".</dd>
            <dt>prohibit</dt>
            <dd>Sends ICMP "administratively prohibited".</dd>
            <dt>throw</dt>
            <dd>Sends "net unreachable".</dd>
          </dl>
          <p>Unlike blackhole routes, these can't be recommended for stopping unwanted traffic (e.g. DDoS)
             because they generate a reply packet for every discarded packet and thus create even greater traffic flow.
             They can be good for implementing internal access policies, but consider firewall for this purpose first.</p>
          <p>"Throw" routes may be used for implementing policy-based routing, in non-default tables they
             stop current table lookup, but don't send ICMP error messages.</p>
        </div>
        <div class="subsection">
          <h4>Routes with different metric</h4>
          <pre>ip route add ${address}/${mask} via ${gateway} metric ${number}</pre>
          <span>Examples:</span>
          <pre>ip route add 192.168.2.0/24 via 10.0.1.1 metric 5</pre>
          <pre>ip route add 192.168.2.0 dev ppp0 metric 10</pre>
          <p>If there are several routes to the same network with different metric value,
                the one with <strong>the lowest</strong> metric will be preferred.</p>
          <p>Important part of this concept is that when an interface goes down, routes
                that would be rendered useless by this event disappear from the routing table (see "Connected Routes" section), and
                the system will fall back to higher metric routes.</p>
          <p>This feature is commonly used to implement backup connections to important destinations.</p>
        </div>
        <div class="subsection">
          <h4>Multipath routing</h4>
          <pre>ip route add ${addresss}/${mask} nexthop via ${gateway 1} weight ${number} nexthop via ${gateway 2} weight ${number}</pre>
          <p>Multipath routes make the system balance packets across several links according to the weight (higher weight is preferred, so
             gateway/interface with weight of 2 will get roughly two times more traffic than with weight of 1). You can have as many gateways
             as you want and mix gateway and interface routes, like:</p>
          <pre>ip route add default nexthop via 192.168.1.1 weight 1 nexthop dev ppp0 weight 10</pre>
          <p> <strong>Warning:</strong> the downside of this type of balancing is that packets are not guaranteed to be sent back
             through the same link they came in. This is called "asymmetric routing". In setups with pure routing that do not
             do any local traffic processing, including NAT, this is usually normal, and in some cases even unavoidable.</p>
          <p>If your system does anything but forwarding packets between interfaces, this may cause problems with incoming connections
             and some measures should be taken to prevent it.</p>
        </div>
      </div>
      <div class="section">
        <h3>Link management</h3>
        <hr />
        <p>Link is another name for network interface. Commands from "ip link" family perform operations
           that are common for all interface types, like viewing link information or setting MTU.</p>
        <p>They also can create many types of interfaces, except for tunnel (IPIP, GRE etc.) and L2TP
            pseudowires that have their own commands.</p>
        <p>Note that interface name you set with "name ${name}" parameter of "ip link add" and "ip link set"
           commands may be arbitrary, and even contain unicode characters. It's better however to stick with
           ASCII because other programs may not handle unicode correctly. Also it's better to use a consistent naming
           convention for link names, and use link aliases to provide human descriptions.</p>
        <div class="subsection">
          <h4>View links</h4>
          <pre>ip link show</pre>
          <pre>ip link list</pre>
          <span>These commands are equivalent and can be used with the same arguments.</span>
        </div>
        <div class="subsection">
          <h4>View single link information</h4>
          <pre>ip link show dev ${interface name}</pre>
          <span>Examples:</span>
          <pre>ip link show dev eth0</pre>
          <pre>ip link show dev tun10</pre>
          <span>The word "dev" may be omitted.</span>
        </div>
        <div class="subsection">
          <h4>Bring link up or down</h4>
          <pre>ip link set dev ${interface name} up</pre>
          <pre>ip link set dev ${interface name} down</pre>
          <span>Examples:</span>
          <pre>ip link set dev eth0 down</pre>
          <pre>ip link set dev br0 up</pre>
          <p><strong>Note:</strong> virtual links described below, like VLANs and bridges
             are in <strong>down</strong> state immediately after creation. You need to bring them up to start using them.</p>
        </div>
        <div class="subsection">
          <h4>Set human-readable link description</h4>
          <pre>ip link set dev ${interface name} alias "${description}"</pre>
          <span>Examples:</span>
          <pre>ip link set dev eth0 alias "LAN interface"</pre>
          <span>Link aliases show up in "ip link show" output, like:</span>
          <pre>
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP mode DEFAULT qlen 1000
    link/ether 22:ce:e0:99:63:6f brd ff:ff:ff:ff:ff:ff
    alias LAN interface
          </pre>
        </div>
        <div class="subsection">
          <h4>Rename an interface</h4>
          <pre>ip link set dev ${old interface name} name ${new interface name}</pre>
          <span>Examples:</span>
          <pre>ip link set dev eth0 name lan</pre>
          <p>Note that you can't rename an active interface. You need to bring it down
             before doing it.</p>
        </div>
        <div class="subsection">
          <h4>Change link layer address</h4>
          <pre>ip link set dev ${interface name} address ${address}</pre>
          <p>Link layer address is a pretty broad concept. The most known 
             example is MAC address for ethernet devices. To change MAC
             address you would need something like:</p>
          <pre>ip link set dev eth0 address 22:ce:e0:99:63:6f</pre>
        </div>
        <div class="subsection">
          <h4>Change link MTU</h4>
          <pre>ip link set dev ${interface name} mtu ${MTU value}</pre>
          <span>Examples:</span>
          <pre>ip link set dev tun0 mtu 1480</pre>
          <p>MTU stands for "Maximum Transmission Unit", the maximum size
             of frames interface can transmit.</p>
          <p>Apart from reducing fragmentation in encapsulated links like
             in example above, this is also used to increase performance of
             gigabit ethernet linkst that support so called "jumbo frames"
             (frames up to 9000 byte large). If all your equipment is
             gig-e enabled, do something like
          <pre>ip link set dev eth0 mtu 9000</pre>
        </div>
        <div class="subsection">
          <h4>Delete a link</h4>
          <pre>ip link delete dev ${interface name}</pre>
          <p>Obviously, only virtual links like VLANs or bridges can be deleted.</p>
        </div>
        <div class="subsection">
          <h4>Enable or disable multicast on an interface</h4>
          <pre>ip link set ${interface name} multicast on</pre>
          <pre>ip link set ${interface name} multicast off</pre>
          <p>Unless you really understand what you are doing, better not to touch this.</p>
        </div>
        <div class="subsection">
          <h4>Enable or disable ARP on an interface</h4>
          <pre>ip link set ${interface name} arp on</pre>
          <pre>ip link set ${interface name} arp off</pre>
          <p>One may want to disable ARP to enforce MAC policy and allow only specific MACs
             to communicate with the interface. Of course it's also needed to add those ARP tables
             entries manually in this case (see <a href="#Neighbor (ARP and NDP) tables management">neighbor table management</a>
             section. </p>
          <p>In most cases it's better to configure MAC policy on the switch port though. Again, do not change this flag
             without thinking first.</p>
        </div>
        <div class="subsection">
          <h4>Create a VLAN interface</h4>
          <pre>ip link add name ${VLAN interface name} link ${parent interface name} type vlan id ${tag}</pre>
          <span>Examples:</span>
          <pre>ip link add name eth0.110 link eth0 type vlan id 110</pre>
          <p>The only type of VLAN supported in Linux is IEEE 802.1q VLAN, legacy implementations like ISL
             are not supported.</p>
          <p>Once you create a VLAN interface, all frames tagged with ${tag} you specified in id option
             received by ${parent interface} will be processed by that VLAN interface.</p>
          <p>eth0.100 name format is traditional, but not required, you can name the interface as you want,
             just like with other interface types.</p>
          <p>VLANs can be created over bridge, bonding and other interfaces capable of processing ethernet frames too.</p>
        </div>
        <div class="subsection">
          <h4>Create a QinQ interface (VLAN stacking)</h4>
          <pre>ip link add name ${second VLAN interface} link ${parent VLAN interface} type vlan id ${tag}</pre>
          <span>Example:</span>
          <pre>ip link add name eth0.100 link eth0 type vlan id 100 # Create parent interface</pre>
          <pre>ip link add name eth0.100.200 link eth0.100 type vlan id 200 # Create child interface</pre>
          <p>VLAN stacking (aka QinQ) is a way to encapsulate a VLAN into other VLAN. The common use case for it
             is transferring customer VLANs through a provider network.</p>
          <p>Note that link MTU for the inner VLAN doesn't get adjusted automatically, you need to take care
             of it yourself and either decrease child interface MTU to at least 4 bytes, or increase parent MTU accordingly.</p>
        </div>
        <div class="subsection">
          <h4>Create pseudo-ethernet (aka macvlan) interface</h4>
          <pre>ip link add name ${macvlan interface name} link ${parent interface} type macvlan</pre>
          <span>Examples:</span>
          <pre>ip link add name peth0 link eth0 type macvlan</pre>
          <p>You can think of macvlan interfaces as additional virtual MAC addresses on the parent interface.
             They look like normal ethernet interfaces from user point of view, and handle all traffic for
             MAC address they are assigned with received by their parent interface.</p>
          <p>This is commonly used for testing, or for using several instances of a service identified by
             MAC when only one physical interface is available.</p>
          <p>They also can be used just for IP address separation instead of assigning multiple addresses
             to the same physical interface, especially if some service can't operate on a secondary address properly.</p>
        </div>
        <div class="subsection">
          <h4>Create a dummy interface</h4>
          <pre>ip link add name ${dummy interface name} type dummy</pre>
          <span>Examples:</span>
          <pre>ip link add name dummy0 type dummy</pre>
          <p>Dummy interfaces work pretty much like loopback interfaces, just there can be as many
             of them as you want.</p>
          <p>The first purpose of them is for communication of programs inside the host.</p>
          <p>The second purpose exploits the fact they are always up (unless administratively taken down).
             This is often used to assign service addresses to them on routers with more than one physical
             interface. As long as the traffic to the address assigned to a loopback or dummy interface
             is routed to the machine that owns it, you can access it through any of its interfaces.</p>
        </div>
        <div class="subsection">
          <h4>Create a bridge interface</h4>
          <pre>ip link add name ${bridge name} type bridge</pre>
          <span>Examples:</span>
          <pre>ip link add name br0 type bridge</pre>
          <p>Bridge interfaces are virtual ethernet switches. They can be used to relay traffic
             transparently between ethernet interfaces, and, increasingly common, as ethernet switches
             for virtual machines running inside hypervisors.</p>
          <p>You can assign an IP address to a bridge and it will be visible from all bridge ports.</p>
          <p>If this command failes, check if "bridge" module is loaded.</p>
        </div>
        <div class="subsection">
          <h4>Add an interface to bridge</h4>
          <pre>ip link set dev ${interface name} master ${bridge name}</pre>
          <span>Examples:</span>
          <pre>ip link set dev eth0 master br0</pre>
          <p>Interface you added to a bridge becomes a virtual switch port. It operates only on datalink
             layer and ceases all network layer operation.</p>
        </div>
        <div class="subsection">
          <h4>Remove interface from bridge</h4>
          <pre>ip link set dev ${interface name} nomaster</pre>
          <span>Examples:</span>
          <pre>ip link set dev eth0 nomaster</pre>
        </div>
        <div class="subsection">
          <h4>Create a bonding interface</h4>
          <pre>ip link add name ${name} type bond</pre>
          <span>Examples:</span>
          <pre>ip link add name bond1 type bond</pre>
          <p><strong>Note:</strong> This is not enough to configure bonding (link aggregation)
             in any meaningful way. You need to set up bonding parameters according to your situation.
             This is far beyond the cheat sheet scope, so consult the documentation. </p>
          <p>Interfaces are added to the bond group the same way to bridge group, just note that you can't
             add it until you take it down.</p>
        </div>
        <div class="subsection">
          <h4>Create an intermediate functional block interface</h4>
          <pre>ip link add ${interface name} type ifb</pre>
          <span>Example:</span>
          <pre>ip link add ifb10 type ifb</pre>
          <p>Intermediate functional block devices are used for traffic redirection and mirroring
             in conjunction with tc. This is also far beyond the scope of this document, consult tc
             documentation.</p>
        </div>
        <div class="subsection">
          <h4>Create a pair of virtual ethernet devices</h4>
          <p>Virtual ethernet (veth) devices always come in pairs and work as a bidirectional pipe,
             whatever comes into one of them, comes out of another. They are used in conjunction with
             system partitioning features such as network namespaces and containers (OpenVZ and LXC)
             for connecting one partition to another.</p>
          <pre>ip link add name ${first device name} type veth peer name ${second device name}</pre>
          <span>Examples:</span>
          <pre>ip link add name veth-host type veth peer name veth-guest</pre>
          <p><strong>Note:</strong> virtual ethernet devices are created in UP state, no need to
             bring them up manually after creation.</p>
        </div>
      </div>
      <div class="section">
        <h3>Neighbor (ARP and NDP) tables management</h3>
        <p>For ladies and gentlemen who prefer UK spelling, this command family supports "neighbour" spelling too.</p>
        <hr />
        <div class="subsection">
          <h4>View neighbor tables</h4>
          <pre>ip neighbor show</pre>
          <p>All "show" commands support -4 and -6 options to view only IPv4 (ARP) or IPv6 (NDP) neighbors. By default
             all neighbors are displayed.</p>
        </div>
        <div class="subsection">
          <h4>View neighbors for single interface</h4>
          <pre>ip neighbor show dev ${interface name}</pre>
          <span>Examples:</span>
          <pre>ip neighbor show dev eth0</pre>
        </div>
        <div class="subsection">
          <h4>Flush table for an interface</h4>
          <pre>ip neighbor flush dev ${interface name}</pre>
          <span>Examples:</span>
          <pre>ip neighbor flush dev eth1</pre>
        </div>
        <div class="subsection">
          <h4>Add a neighbor table entry</h4>
          <pre>ip neighbor add ${network address} lladdr ${link layer address} dev ${interface name}</pre>
          <span>Examples:</span>
          <pre>ip neighbor add 192.0.2.1 lladdr 22:ce:e0:99:63:6f dev eth0</pre>
          <p>One of the use cases for it is to add static entry for an interface with disabled ARP to
             restrict interface usage only by hosts with specific MAC addresses.</p>
        </div>
        <div class="subsection">
          <h4>Delete a neighbor table entry</h4>
          <pre>ip neighbor delete ${network address} lladdr ${link layer address} dev ${interface name}</pre>
          <span>Examples:</span>
          <pre>ip neighbor delete 192.0.2.1 lladdr 22:ce:e0:99:63:6f dev eth0</pre>
          <p>Allows to delete a static entry, or get rid ot an automatically learnt entry without flushing the table.</p>
        </div>
      </div>
      <div class="section">
        <h3>Tunnel management</h3>
        <hr /> 
        <p>Tunnels are "network wormholes" that look like normal interfaces,
           but packets sent to them are encapsulated into a network layer protocol
           and sent to the other side of tunnel through multiple hosts, then 
           decapsulated and processed in usual way. So you can pretend two
           machines have direct connectivity, while they in fact do not.</p>
        <p>This is often used for virtual private networks (in conjunction with
           encrypted transport protocols like IPsec), or connecting networks
           that use some protocol via an intermediate network that does not
           (e.g. IPv6 networks via an IPv4 network).</p>
        <p><strong>Note:</strong> tunnels on their own offer zero security.
           They are as secure as their underlying network. So if you need
           security, use them over an encrypted transport, e.g. IPsec.</p>
        <p>Linux currently supports IPIP (IPv4 in IPv4), SIT (IPv6 in IPv4),
           IP6IP6 (IPv6 in IPv6), IPIP6 (IPv4 in IPv6), GRE (virtually anything
           in anything), and, in very recent versions, VTI (IPv4 in IPsec).</p>
        <p>Note that tunnels are created in DOWN state, you need to bring them up.</p>
        <p>In this section ${local endpoint address} and ${remote endpoint address}
           refer to addresses assigned to physical interfaces of endpoint. ${address}
           refers to the address assigned to tunnel interface.</p>
        <div class="subsection">
          <h4>Create an IPIP tunnel</h4>
          <pre>ip tunnel add ${interface name} mode ipip local ${local endpoint address} remote ${remote endpoint address}</pre>
          <span>Examples:</span>
          <pre>ip runnel add tun0 mode ipip local 192.0.2.1 remote 198.51.100.3</pre>
          <pre>ip link set dev tun0 up</pre>
          <pre>ip address add 10.0.0.1/30 dev tun0</pre>
        </div>
        <div class="subsection">
          <h4>Create a SIT tunnel</h4>
          <pre>sudo ip tunnel add ${interface name} mode sit local ${local endpoint address} remote ${remote endpoint address}</pre>
          <span>Examples:</span>
          <pre>ip tunnel add tun9 mode sit local 192.0.2.1 remote 198.51.100.3</pre>
          <pre>ip link set dev tun9 up</pre>
          <pre>ip address add 2001:db8:1::1/64 dev tun9</pre>
          <p>This type of tunnels is commonly used to provide an IPv4-connected network with
             IPv6 connectivity. There are so called "tunnel brokers" that provide it to everyone interested,
             e.g. Hurricane Electric <a href="http://tunnelbroker.net">tunnelbroker.net</a>.</p>
        </div>
        <div class="subsection">
          <h4>Create an IPIP6 tunnel</h4>
          <pre> ip -6 tunnel add ${interface name} mode ipip6 local ${local endpoint address} remote ${remote endpoint address}</pre>
          <span>Examples:</span>
          <pre>ip -6 tunnel add tun8 mode ipip6 local 2001:db8:1::1 remote 2001:db8:1::2</pre>
          <p>This type of tunnels will be widely used when transit operators phase IPv4 out (i.e. not any soon).</p>
        </div>
        <div class="subsection">
          <h4>Create an IP6IP6 tunnel</h4>
          <pre>ip -6 tunnel add ${interface name} mode ip6ip6 local ${local endpoint address} remote ${remote endpoint address}</pre>
          <span>Examples:</span>
          <pre>ip -6 tunnel add tun3 mode ip6ip6 local 2001:db8:1::1 remote 2001:db8:1::2</pre>
          <pre>ip link set dev tun3 up</pre>
          <pre>ip address add 2001:db8:2:2::1/64 dev tun3</pre>
          <p>Just like IPIP6 these ones aren't going to be generally useful any soon.</p>
        </div> 
        <div class="subsection">
          <h4>Create a gretap (ethernet over GRE) device</h4>
          <pre>ip link add ${interface name} type gretap local ${local endpoint address} remote ${remote endpoint address}</pre>
          <span>Examples:</span>
          <pre>ip link add gretap0 type gretap local 192.0.2.1 remote 203.0.113.3</pre>
          <p>This type of tunnels encapculates ethernet frames into IPv4 packets.</p>
          <p>This probably should have been in "Links management" section, but as it involves encapsulation, it's here.
             Tunnel interface created this way looks like an L2 link, and it can be added to a bridge group. This is used
             to connect L2 segments via a routed network.</p>
        </div>
        <div class="subsection">
          <h4>Create a GRE tunnel</h4>
          <pre>ip tunnel add ${interface name} mode gre local ${local endpoint address} remote ${remote endpoint address}</pre>
          <span>Examples:</span>
          <pre>ip tunnel add tun6 mode gre local 192.0.2.1 remote 203.0.113.3</pre>
          <pre>ip link set dev tun6 up</pre>
          <pre>ip address add 192.168.0.1/30 dev tun6</pre>
          <pre>ip address add 2001:db8:1::1/64 dev tun6</pre>
          <p>GRE can encapsulate both IPv4 and IPv6 at the same time.</p>
        </div>
        <div class="subsection">
          <h4>Create multiple GRE tunnels to the same endpoint</h4>
          <pre>ip tunnel add ${interface name} mode gre local ${local endpoint address} remote ${remote endpoint address} key ${key value}</pre>
          <span>Examples:</span>
          <pre>ip tunnel add tun4 mode gre local 192.0.2.1 remote 203.0.113.6 key 123</pre>
          <pre>ip tunnel add tun5 mode gre local 192.0.2.1 remote 203.0.113.6 key 124</pre>
          <p>Keyed tunnels can be used at the same time to unkeyed too. Key may be in dotted decimal IPv4-like format.</p>
          <p>Note that key does not add any security to the tunnel. It's just an identifier used to distinguish one tunnel from another.</p>
        </div>
        <div class="subsection">
          <h4>Create a point-to-multipoint GRE tunnel</h4>
          <pre>ip tunnel add ${interface name} mode gre local ${local endpoint address} key ${key value}</pre>
          <span>Examples:</span>
          <pre>ip tunnel add tun8 mode gre local 192.0.2.1 key 1234</pre>
          <pre>ip link set dev tun8 up</pre>
          <pre>ip address add 10.0.0.1/27 dev tun8</pre>
          <p>Note the absence of ${remote endpoint address}. This is the same to what Cisco calls "mode gre multipoint".</p>
          <p>In the absence of remote endpoint address the key is the only way to identify the tunnel traffic, so ${key value} is required.</p>
          <p>This type of tunnel allows to communicate with multiple endpoints on the same interface. It's commonly used for
             complex VPN setups with multiple endpoints communicating to each other (in Cisco terminology,  "dynamic multipoint VPN").</p>
          <p>As there is no explicit remote endpoint address, obviously it's not enough to just create the tunnel. Your system needs to know
             where other endpoints are.</p>
          <p>In real life NHRP (Next Hop Resolution Protocol) is used for it. For testing you can add peers manually (given remote endpoint
              has 203.0.113.6 address on its physical interface and 10.0.0.2 on tunnel):</p>
          <pre>ip neighbor add 10.0.0.2 lladdr 203.0.113.6 dev tun8</pre>
          <p>You will have to do it on the remote endpoint too, like:</p>
          <pre>ip neighbor add 10.0.0.1 lladd 192.0.2.1 dev tun8</pre>
          <p>Note that link-layer address is in this case an address of the same protocol. This one of the cases where link-layer address
             concept gets interesting.</p>
        </div>
        <div class="subsection">
          <h4>Delete a tunnel</h4>
          <pre>ip tunnel del ${interface name}</pre>
          <span>Examples:</span>
          <pre>ip tunnel del gre1</pre>
          <p>Note that this command does not support the word "delete", "del" is its full word.</p>
        </div>
        <div class="subsection">
          <h4>Modify a tunnel</h4>
          <pre>ip tunnel change ${interface name} ${options}</pre>
          <span>Examples:</span>
          <pre>ip tunnel change tun0 remote 203.0.113.89</pre>
          <pre>ip tunnel change tun10 key 23456</pre>
          <p> <strong>Note:</strong> Apparently you can't add a key to previously unkeyed tunnel.
              Not sure if it's a bug or a feature. Also, you can't change tunnel mode on the fly,
              for obvious reasons.</p>
        </div>
        <div class="subsection">
          <h4>View tunnel information</h4>
          <pre>ip tunnel show</pre>
          <pre>ip tunnel show ${interface name}</pre>
          <span>Examples:</span>
          <pre>$ip tun show tun99 
tun99: gre/ip  remote 10.46.1.20  local 10.91.19.110  ttl inherit 
          </pre>
        </div>
      </div>
      <div class="section">
        <h3>L2TPv3 pseudowire management</h3>
        <p><a href="http://tools.ietf.org/html/rfc3931">L2TPv3</a> is a tunneling
           protocol commonly used for L2 pseudowires.</p>
        <p>In many distros L2TPv3 is compiled as a module, and may not be loaded by default.
           If you get a "RTNETLINK answers: No such file or directory" and "Error talking to the kernel" message
           to any "ip l2tp" command, this is likely the case. Load <strong>l2tp_netlink</strong> and
           <strong>l2tp_eth</strong> modules. If you want to use L2TPv3 over IP rather than UDP, also load
           <strong>l2tp_ip</strong>.</p>
        <p>Compared to other tunneling protocol implementations in Linux, L2TPv3 terminology is somewhat
           reversed. You create a <em>tunnel</em>, and then bind <em>sessions</em> to it. You can bind
           multiple sessions with different identifiers to the same tunnel. Virtual network interfaces
           (by default named l2tpethX) are associated with <em>sessions</em>.</p>
        <p> <strong>Note:</strong> Linux kernel implements only handling of data frames, so you can create
            only unmaged tunnels with iproute2, with all settings configured manually on both sides.
            If you want to use L2TP for remote access VPN or something else other than fixed
            pseudowire, you need a userspace daemon to handle it. This is outside of this document scope.</p>
        <div class="subsection">
          <h4>Create an L2TPv3 tunnel over UDP</h4>
          <pre>
ip l2tp add tunnel \
tunnel_id ${local tunnel numeric identifier} \
peer_tunnel_id ${remote tunnel numeric identifier} \
udp_sport ${source port} \
udp_dport ${destination port} \
encap udp \
local ${local endpoint address} \
remote ${remote endpoint address}
</pre>
          <span>Examples:</span>
       	  <pre>
ip l2tp add tunnel \
tunnel_id 1 \
peer_tunnel_id 1 \
udp_sport 5000 \
udp_dport 5000 \ 
encap udp \
local 192.0.2.1 \ 
remote 203.0.113.2
</pre>
         <p><strong>Note:</strong> Tunnel identifiers and other settings on both endpoints must match.</p>
        </div>
        <div class="subsection">
          <h4>Create an L2TPv3 tunnel over IP</h4>
          <pre>ip l2tp add tunnel \
tunnel_id ${local tunnel numeric identifier} \
peer_tunnel_id {remote tunnel numeric identifier } \
encap ip \
local 192.0.2.1 \
remote 203.0.113.2
          </pre>
          <p>L2TPv3 encapsulated directly into IP offers less overhead,
             bug generally is unable to pass through NAT.</p>
        </div>
        <div class="subsection">
          <h4>Create an L2TPv3 session</h4>
          <pre>ip l2tp add session tunnel_id ${local tunnel identifier} \
session_id ${local session numeric identifier} \
peer_session_id ${remote session numeric identifier}
          </pre>
          <span>Examples:</span>
       	  <pre>ip l2tp add session tunnel_id 1 \ 
session_id 10 \
peer_session_id 10
       	  </pre>
          <p> <strong>Notes:</strong> tunnel_id value must match a value of previously created tunnel.
              Session identifiers on both endpoints must match.</p>
           <p>Once you create a tunnel and a session, l2tpethX interface will appear, in down state. Change the state
       	   to up and bridge it with another interface or assign	an address.</p>
        </div>
        <div class="subsection">
          <h4>Delete an L2TPv3 session</h4>
          <pre>ip l2tp del session tunnel_id ${tunnel identifier} \
session_id ${session identifier}
          </pre>
          <span>Examples</span>
          <pre>ip l2tp del session tunnel_id 1 session_id 1</pre>
        </div>
        <div class="subsection">
          <h4>Delete an L2TPv3 tunnel</h4>
          <pre>ip l2tp del tunnel tunnel_id ${tunnel identifier}</pre>
          <span>Examples</span>
          <pre>ip l2tp del tunnel tunnel_id 1</pre>
          <p> <strong>Note:</strong> You need to delete all sessions associated
              with a tunnel before deleting it.</p>
        </div>
        <div class="subsection">
          <h4>View L2TPv3 tunnel information</h4>
          <pre>ip l2tp show tunnel</pre>
          <pre>ip l2tp show tunnel tunnel_id ${tunnel identifier}</pre>
          <span>Examples:</span>
          <pre>ip l2tp show tunnel tunnel_id 12</pre>
        </div>
       	<div class="subsection">
       	  <h4>View L2TPv3 session information</h4>
       	  <pre>ip l2tp show session</pre>
       	  <pre>ip l2tp show session session_id ${session identifier} \
tunnel_id ${tunnel identifier}
          </pre>
       	  <span>Examples:</span>
       	  <pre>ip l2tp show session session_id 1 tunnel_id 12</pre>
        </div>
      </div>
      <div class="section">
        <h3>Policy-based routing</h3>
        <p>Policy-based routing (PBR) in Linux is designed the following way:
           first you create custom routing tables, then you create rules to tell
           the kernel use those tables instead of default for specific traffic.</p>
        <p>Some tables are predefined:</p>
        <dl>
          <dt> <strong>local</strong> (table 255)</dt>
          <dd>Contains control routes local and broadcast addresses.</dd>
          <dt> <strong>main</strong> (table 254)</dt>
          <dd>Contains all non-PBR routes. If you don't specify the table when adding a route, it goes here.</dd>
          <dt> <strong>default</strong> (table 253)</dt>
          <dd> Reserved for postprocessing, normally unused.</dd>
        </dl>
        <p>User-defined tables are created automatically when you add the first route to them.</p>
        <div class="subsection">
          <h4>Create a policy route</h4>
          <pre>ip route add ${route options} table ${table id or name}</pre>
          <span>Examples:</span>
          <pre>ip route add 192.0.2.0/27 via 203.0.113.1 table 10</pre>
          <pre>ip route add 0.0.0.0/0 via 192.168.0.1 table ISP2</pre>
          <pre>ip route add 2001:db8::/48 dev eth1 table 100</pre>
          <p> <strong>Notes:</strong> You can use any route options described in "Route management" section
              in policy routes too, the only different is the "table ${table id/name}" part at the end.</p>
          <p>Numeric table identifiers and names can be used interchangeably. To create your own symbolic
             names, edit <strong>/etc/iproute2/rt_tables</strong> config file.</p>
          <p>"delete", "change", "replace", or any other route actions work with any table too.</p>
       	  <p>"ip route ... table main" or "ip route ... table 254" would have exact same effect to not specifying table at all.</p>
        </div>
        <div class="subsection">
          <h4>View policy routes</h4>
          <pre>ip route show table ${table id or name}</pre>
          <span>Examples:</span>
          <pre>ip route show table 100</pre>
          <pre>ip route show table test</pre>
          <p> <strong>Note:</strong> in this case you need the "show" word, the shortands like "ip route table 120"
              do not work because the command would be ambiguous.</p>
        </div>
        <div class="subsection">
          <h4>General rule syntax</h4>
          <pre>ip rule add ${options} &lt;lookup ${table id or name}|blackhole|prohibit|unreachable&gt;</pre>
          <p>Traffic that matches the ${options} (described below) will be routed
             according to the table ${table id or name} instead of the "main"/254 table if "table" action is used.</p>
          <p>"blackhole", "prohibit", and "unreachable" actions that work the same way to route types with same names.
             In most of examples we will use "lookup" action as the most common.</p>
          <p>For IPv6 rules, use "ip -6", the rest of the syntax is the same.</p>
          <p>"table ${table id or name}" can be used as alias to "lookup ${table id or name}".</p>
        </div>
        <div class="subsection">
          <h4>Create a rule to match source network</h4>
          <pre>ip rule add from ${source network} ${action}</pre>
          <span>Examples:</span>
          <pre>ip rule add from 192.0.2.0/24 lookup 10</pre>
          <pre>ip -6 rule add from 2001:db8::/32 prohibit</pre>
          <p><strong>Notes:</strong> "all" can be used as shortand to 0.0.0.0/0 or ::/0</p>
        </div>
        <div class="subsection">
          <h4>Create a rule to match destination network</h4>
          <pre>ip rule add to ${destination network} ${action}</pre>
          <span>Examples:</span>
          <pre>ip rule add to 192.0.2.0/24 blackhole</pre>
          <pre>ip -6 rule add to 2001:db8::/32 lookup 100</pre>
        </div>
        <div class="subsection">
          <h4>Create a rule to match ToS field</h4>
          <pre>ip rule add tos ${ToS value} ${action}</pre>
          <span>Examples:</span>
          <pre>ip rule add tos 0x10 lookup 110</pre>
        </div>
        <div class="subsection">
          <h4>Create a rule to match firewall mark</h4>
          <pre>ip rule add fwmark ${mark} ${action}</pre>
          <span>Examples:</span>
          <pre>ip rule add fwmark 0x11 lookup 100</pre>
          <p><strong>Note:</strong> See iptables documentation to find out how to set the mark.</p>
        </div>
        <div class="subsection">
          <h4>Create a rule to match inbound interface</h4>
          <pre>ip rule add iif ${interface name} ${action}</pre>
          <span>Examples:</span>
          <pre>ip rule add iif eth0 lookup 10</pre>
          <pre>ip rule add iif lo lookup 20</pre>
          <p>Rule with "iif lo" (loopback) will match locally generated traffic.</p>
        </div>
        <div class="subsection">
          <h4>Create a rule to match outbound interface</h4>
          <pre>ip rule add oif ${interface name} ${action}</pre>
          <span>Examples:</span>
          <pre>ip rule add oif eth0 lookup 10</pre>
          <p><strong>Note:</strong> this works only for locally generated traffic.</p>
        </div>
        <div class="subsection">
          <h4>Set rule priority</h4>
          <pre>ip rule add ${options} ${action} priority ${value}</pre>
          <span>Examples:</span>
          <pre>ip rule add from 192.0.2.0/25 lookup 10 priority 10</pre>
          <pre>ip rule add from 192.0.2.0/24 lookup 20 priority 20</pre>
          <p><strong>Note:</strong> As rules are traversed from the lowest to the highest
             priority and processing stops at first match, you need to put more specific rules
             before less specific. The above example demonstrates rules for 192.0.2.0/24 and its
             subnet 192.0.2.0/25. If the priorities were reversed and the rule for /25 was placed
             after the rule for /24, it would never be reached.</p>
        </div>
        <div class="subsection">
          <h4>Show all rules</h4>
          <pre>ip rule show</pre>
          <pre>ip -6 rule show</pre>
        </div>
        <div class="subsection">
          <h4>Delete a rule</h4>
          <pre>ip rule del ${options} ${action}</pre>
          <span>Examples:</span>
          <pre>ip rule del 192.0.2.0/24 lookup 10</pre>
          <p><strong>Notes:</strong> You can copy/paste from the output of "ip rule show"/"ip -6 rule show".</p>
        </div>
        <div class="subsection">
          <h4>Delete all rules</h4>
          <pre>ip rule flush</pre>
          <pre>ip -6 rule flush</pre>
          <p><strong>Notes:</strong> this operation is <strong>highly disruprive</strong>. Even if you have not
             configured any rules, "from all lookup main" rules are initialized by default. On an unconfigured
             machine you can see this:</p>
<pre>
$ ip rule show
0:	from all lookup local 
32766:	from all lookup main 
32767:	from all lookup default 

$ ip -6 rule show
0:	from all lookup local 
32766:	from all lookup main 
</pre>
          <p>The "from all lookup local" rule is special and can not be deleted. The "from all lookup main" is not,
             there may be valid reasons not to have it, e.g. if you want to route only traffic you created explicit
             rules for. As a side effect, if you do "ip rule flush", this rule will be deleted, which will make the
             system <strong>stop routing any traffic</strong> until you restore your rules.</p>
        </div>
      </div>
      <div class="section">
        <h3>netconf (sysctl configuration viewing)</h3>
        <div class="subsection">
          <h4>View sysctl configuration for all interfaces</h4>
          <pre>ip netconf show</pre>
        </div>
        <div class="subsection">
          <h4>View sysctl configuration for specific interface</h4>
          <pre>ip netconf show dev ${interface}</pre>
          <span>Examples:</span>
          <pre>ip netconf show dev eth0</pre>
        </div>
      </div>
      <div class="section">
        <h3>Network namespace management</h3>
        <p>Network namespaces are isolated network stack instances within a single machine. They can be used
           for security domain separation, managing traffic flows between virtual machines and so on.</p>
        <p>Every namespace is a complete copy of the networking stack with its own interfaces, addresses,
           routes etc. You can run processes inside a namespace and bridge namespaces to physical interfaces.</p>
        <div class="subsection">
          <h4>Create a namespace</h4>
          <pre>ip netns add ${namespace name}</pre>
          <span>Examples:</span>
          <pre>ip netns add foo</pre>
        </div>
        <div class="subsection">
          <h4>List existing namespaces</h4>
          <pre>ip netns list</pre>
        </div>
        <div class="subsection">
          <h4>Delete a namespace</h4>
          <pre>ip netns delete ${namespace name}</pre>
          <span>Examples:</span>
          <pre>ip netns delete foo</pre>
        </div>
        <div class="subsection">
          <h4>Run a process inside a namespace</h4>
          <pre>ip netns exec ${namespace name} ${command}</pre>
          <span>Examples:</span>
          <pre>ip netns exec foo /bin/sh</pre>
          <p><strong>Note:</strong> assigning a process to a non-default namespace requires
             root privileges.</p>
          <p>You can run any processes inside a namespace, in particular you can run "ip"
             itself, commands like in this "ip netns exec foo ip link list" in this section
             are not a special syntax but simply executing another copy of "ip" in a namespace.
             You can run an interactive shell inside a namespace as well.</p>
        </div>
        <div class="subsection">
          <h4>List all processes assigned to a namespace</h4>
          <pre>ip netns pids ${namespace name}</pre>
          <p>The output will be a list of PIDs.</p>
        </div>
        <div class="subsection">
          <h4>Identify process' primary namespace</h4>
          <pre>ip netns identify ${pid}</pre>
          <span>Examples:</span>
          <pre>ip netns identify 9000</pre>
        </div>
        <div class="subsection">
          <h4>Assign network interface to a namespace</h4>
          <pre>ip link set dev ${interface name} netns ${namespace name}</pre>
          <pre>ip link set dev ${interface name} netns ${pid}</pre>
          <span>Examples:</span>
          <pre>ip link set dev eth0.100 netns foo</pre>
          <p><strong>Note:</strong> once you assign an interface to a namespace, it disappears
             from the default namespace and you will have to perform all operations with it via
             "ip netns exec ${netspace name}", as in "ip netns exec ${netspace name} ip link set dev dummy0 down".</p>
          <p>Moreover, when you move an interface to another namespace, it loses all existing configuration
             such as IP addresses configured on it and goes to DOWN state. You need to bring it back up and
             reconfigure.</p>
          <p>If you specify a PID instead of a namespace name, the interface gets assigned to the primary
             namespace of the process with that PID. This way you can reassign an interface back to default
             namespace with e.g. "ip netns exec ${namespace name} ip link set dev ${intf} netns 1" 
             (since init or another process with PID 1 is pretty much guaranteed to be in default namespace).</p>
        </div>
        <div class="subsection">
          <h4>Connect one namespace to another</h4>
          <p>This can be done by creating two veth links and assigning them two different namespaces.
             Suppose you want to connect namespace "foo" to the default namespace.</p>
          <span>Create a pair of veth devices:</span>
          <pre>ip link add name veth1 type veth peer name veth2</pre>
          <span>Move veth2 to namespace foo:</span>
          <pre>ip link set dev veth2 netns foo</pre>
          <span>Bring veth2 and add an address in "foo" namespace:</span>
          <pre>ip netns exec foo ip link set dev veth2 up</pre>
          <pre>ip netns exec foo ip address add 10.1.1.1/24 dev veth2</pre>
          <span>Add an address to veth1, which stays in the default namespace:</span>
          <pre>ip address add 10.1.1.2/24 dev veth1</pre>
          <p>Now you can ping 10.1.1.1 which if in foo namespace, and setup routes to
             subnets configured in other interfaces of that namespace.</p>
          <p>If you want switching instead of routing, you can bridge those veth
             interfaces with other interfaces in corresponding namespaces. Same technique
             can be used to connect namespaces to physical networks.</p>
        </div>
        <div class="subsection">
          <h4>Monitor network namespace subsystem events</h4>
          <pre>ip netns monitor</pre>
          <p>Displays events such as creation and deletion of namespaces when they occur.</p>
        </div>
      </div>
      <div class="section">
        <h3>VXLAN management</h3>
        <p>VXLAN is a layer 2 tunneling protocol that is commonly used in conjunction with
           virtualization systems such as KVM to connect virtual machines running on different
           hypervisor nodes to each other and to outside world.</p>
        <p>Unlike GRE or L2TPv3 that are point to point, VXLAN replicates some properties of
           multiple access networks by using IP multicast. Also it provides a built-in virtual network
           separation by transmitting a network identifier along with the frame.</p>
      </div>
      <div class="contributors">
        <h3>Contributors:</h3>
        <p>Nicolas Dichtel: netconf section.</p>
      </div>
      <div class="copyright">
        <span>Copyright &copy; Daniil Baturin &lt;daniil at baturin dot org&gt;, 2013.</span> <br /><br />
        <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />
        <br />
      </div>
    </div>
  </body>
</html>
